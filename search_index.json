[
["assignment.html", "6 Assignment 6.1 Assignment 1 6.2 Assignment 2", " 6 Assignment In this R tutorial you will implement the exercises from the assignment in R. 6.1 Assignment 1 The solution of the first assignment can be downloaded here. 6.1.1 Exercise 1 In the first exercise you computed a number of statistics for a distribution with cdf \\[ F_X(x) = \\begin{cases} 0 &amp; x &lt; 0 \\\\ 1-0.5\\cdot e^{-\\beta\\cdot x} &amp; x \\geq 0\\end{cases}, \\] for some \\(\\beta &gt; 0\\). You can use the following function to simulate data from this distribution. Simulating from a given cdf will be covered in a later R tutorial. simulate_assignment1 &lt;- function(num_sim, beta) { rexp(num_sim, rate = beta) * (runif(num_sim) &gt; 0.5) } # this code simulates 10 observations from this distribution with beta = 0.5 simulate_assignment1(10, beta = 0.5) ## [1] 0.16760811 0.00000000 0.00000000 0.01065588 0.70093043 0.17834015 ## [7] 0.00000000 0.00000000 0.00000000 0.82574831 Choose a value for \\(\\beta\\) and simulate 10.000 observations from this distribution. Using this simulation, compute: Plot the empirical cdf of your simulation. \\(P(X = 0)\\) \\(E(X)\\) \\(\\sigma(X) = \\sqrt{E((X - E(X))^2)}\\) Compare your answers with the solution of the assignment. # set the seed for replicability when working with random numbers set.seed(1) n &lt;- 10000 beta = 0.1 simul &lt;- simulate_assignment1(n, beta) # @1 ggplot() + theme_bw() + stat_ecdf(aes(simul)) # @2 sum(simul == 0) / n ## [1] 0.5018 #@3 mean(simul) ## [1] 4.92235 0.5/beta ## [1] 5 #@4 sd(simul) ## [1] 8.594673 sqrt(0.75)/beta ## [1] 8.660254 Next, we calculate \\(E((X-30)_+)\\). To calculate an expected value of the form \\(E(g(X))\\) from a simulation, we compute \\[ \\widehat{E(g(X))} = \\frac{1}{n}\\sum_{i=1}^n g(x_i),\\] where \\(x_i\\) are our simulated outcomes from the random variable \\(X\\). In the case of the mean \\(E(X)\\), \\(g(x) = x\\), i.e. the identity function. We implement this function in R as identity &lt;- function(x) { return(x) } mu = 1/n * sum(identity(simul)) print(mu) ## [1] 4.92235 You will now calculate the expected loss when there is a deductible of \\(30\\) using your simulated data. Write a function deductible taking as input x (a vector containing the loss amounts) and d (the deductible) and returning a vector \\(y\\) with \\(y_i = (x_i-d)_+ = \\max(x_i-d, 0)\\); Test the function deductible that you defined in the previous step. What is the output for dedutible(c(500, 200), 300). Is your function working as expected? A common mistake in implementing the deductible function is a misunderstanding of the max function in R; # returns the maximum of 1, 3 and 2 max(c(1, 3), 2) ## [1] 3 # returns a vector containing max(1, 2) and max(3, 2) pmax(c(1, 3), 2) ## [1] 2 3 Calculate \\(E(X-30)_+\\) for your simulated vector. deductible &lt;- function(x, d) { return(pmax(x-d, 0)) } 1/n * sum(deductible(simul, 30)) ## [1] 0.2519416 0.5 * exp(-30*beta) / beta ## [1] 0.2489353 You will now calculate the remaining statistics from exercise 1. \\(E(X \\wedge 30)\\) \\(e_X(30)\\) \\(VaR_{0.95}(X)\\) # @1 limit &lt;- function(x, limit) { return(pmin(x, limit)) } mean(limit(simul, 30)) ## [1] 4.670408 0.5/beta * (1-exp(-30*beta)) ## [1] 4.751065 # @2 simul_excess_30 &lt;- simul[simul &gt; 30] - 30 mean(simul_excess_30) ## [1] 10.11814 1/beta ## [1] 10 # @3 quantile(simul, 0.95) ## 95% ## 22.91359 -log(0.1)/beta ## [1] 23.02585 6.2 Assignment 2 6.2.1 Exercise 2 You will solve a slightly adapted version of this exercise. Assume that the number of claims, \\(N\\), for an insurance portfolio follows a Poisson distribution with mean \\(\\lambda= 10\\). The sizes of these claims are independent and follow a Gamma distribution with mean 1000 and variance 90000. In this exercise you will compute various statistics related to the total loss. Create a single simulation for the aggregate loss \\(S = X_1 + ... + X_N\\). set.seed(1) lambda &lt;- 10 mu &lt;- 1000 sigmasq &lt;- 90000; # Simulate the number of claims from a Poisson distribution N &lt;- rpois(1, lambda) We have to simulate N losses from a gamma distribution with mean 1000 and variance 90000. When we check the documentation of rgamma we see that the distribution is parametrized by a shape and scale parameter. In the details section of the documentation, you find: \\[shape = a, scale = s, E(X) = a*s \\text{ and } Var(X) = a*s^2.\\] From this you can compute: \\[scale = \\frac{Var(X)}{E(X)} \\text{ and } shape = \\frac{E(X)}{scale}\\] scale = sigmasq / mu shape = mu / scale # Simulate N losses from a gamma distribution X &lt;- rgamma(N, shape = shape, scale = scale) S = sum(X) You have now created a single simulation of \\(S\\). Using a for-loop, you can generate multiple simulations. num_sim &lt;- 1000 # create a vector for storing the result of the simulation aggregated_loss &lt;- rep(NA, num_sim) for(i in 1:num_sim) { # Add your code for a single simulation here N &lt;- X &lt;- S &lt;- aggregated_loss[i] &lt;- S } You will now update the for-loop above to analyze the aggregated loss. Complete the for-loop and generate 1000 simulations of the aggregated loss; Use your simulations to compute the mean and standard deviation of the aggregated loss; Assume that the insurer imposes an ordinary deductible of 750. Compute in your simulation the number of claims that exceed the deductible and the aggregate loss after imposing the deductible; Visualize the distribution of the number of claims before and after imposing the deductible; Compare the density of the aggregate loss before and after imposing the deductible. # @1 num_sim &lt;- 1000 # create a vector for storing the result of the simulation aggregated_loss &lt;- rep(NA, num_sim) for(i in 1:num_sim) { # Add your code for a single simulation here N &lt;- rpois(1, lambda) X &lt;- rgamma(N, shape = shape, scale = scale) S &lt;- sum(X) aggregated_loss[i] &lt;- S } # @2 mean(aggregated_loss) ## [1] 9999.121 sd(aggregated_loss) ## [1] 3316.472 # @3 num_sim &lt;- 1000 # create a vector for storing the result of the simulation deductible &lt;- 750 aggregated_loss &lt;- rep(NA, num_sim) aggregated_loss_deductible &lt;- rep(NA, num_sim) N &lt;- rep(NA, num_sim) N_after_deductible &lt;- rep(NA, num_sim) for(i in 1:num_sim) { # Add your code for a single simulation here N[i] &lt;- rpois(1, lambda) X &lt;- rgamma(N[i], shape = shape, scale = scale) S &lt;- sum(X) aggregated_loss[i] &lt;- S N_after_deductible[i] &lt;- sum(X &gt; deductible) aggregated_loss_deductible[i] &lt;- sum(X[X &gt; deductible]) } df &lt;- rbind(data.frame(count = N, method = &#39;before deductible&#39;), data.frame(count = N_after_deductible, method = &#39;after_deductible&#39;)) ggplot(df) + theme_bw() + geom_bar(aes(count, fill = method, y = ..prop.., group = method), position = position_dodge()) ggplot() + theme_bw() + geom_density(aes(aggregated_loss, fill = &quot;before_dectitble&quot;), alpha = .5) + geom_density(aes(aggregated_loss_deductible, fill = &quot;after_dectitble&quot;), alpha = .5) "]
]
